import { NextResponse } from "next/server";
import { getUserFromRequest } from "../../../../../../lib/auth";
import { isAdminUser } from "../../../../../../lib/admin";
import { getOrderDetail, updateIntakeOutputs, updateOrderStatus, createArtifact } from "../../../../../../lib/orders";
import { getTier } from "../../../../../../lib/pricing";
import { runQC } from "../../../../../../lib/qc";
import { createQcResult } from "../../../../../../lib/qc/persist";
import { repairArtifacts } from "../../../../../../lib/qc/repair";
import { renderReportPdf } from "../../../../../../lib/report/renderReportPdf";
import { renderResumeDocx } from "../../../../../../lib/report/renderResumeDocx";
import { renderResumePdf } from "../../../../../../lib/report/renderResumePdf";
import { uploadBuffer } from "../../../../../../lib/storage";
import type { JobPreferences } from "../../../../../../lib/jobs/types";
import type { ScoredJob } from "../../../../../../lib/jobs/types";
import type { ResumeProfile } from "../../../../../../lib/llm/extractResumeProfile";
import { sendEmail } from "../../../../../../lib/email";
import { replaceJobsForRun } from "../../../../../../lib/jobs/persist";

function pickLatestRun(runs: Array<{ created_at?: string | null; jobs?: unknown[]; id?: string }> = []) {
  return [...runs].sort((a, b) => {
    const aTime = a.created_at ? Date.parse(a.created_at) : 0;
    const bTime = b.created_at ? Date.parse(b.created_at) : 0;
    return bTime - aTime;
  })[0];
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const user = await getUserFromRequest(request);
    if (!isAdminUser(user)) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = (await request.json()) as { action?: "rerun" | "repair" };
    const action = body.action ?? "rerun";

    const order = await getOrderDetail(id);
    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    const tier = getTier(order.tier_id ?? order.product_tier ?? "");
    if (!tier) {
      return NextResponse.json({ error: "Tier not found" }, { status: 400 });
    }

    const intake = order.intakes?.[0];
    if (!intake) {
      return NextResponse.json({ error: "Intake missing" }, { status: 400 });
    }

    const latestRun = pickLatestRun(order.job_runs ?? []);
    const jobs = (latestRun?.jobs ?? []) as ScoredJob[];

    const resumeProfile = (intake.resume_profile_json ?? {}) as ResumeProfile;
    const resumeDraft = intake.resume_ats_text ?? intake.resume_patch_notes ?? "";
    const outreachDraft = intake.outreach_text ?? "";
    const gapDraft = intake.gap_suggestions ?? [];
    const certDraft = intake.cert_suggestions ?? [];
    const keywordMap = intake.keyword_map ?? [];

    if (action === "repair") {
      await updateOrderStatus(id, "qc_repairing");
      const repaired = await repairArtifacts({
        orderId: id,
        tier,
        jobs,
        resumeProfile,
        resumeDraft,
        outreachDraft,
        gapDraft,
        certDraft,
        keywordMap,
        targetTitles: intake.target_titles ?? [],
        preferences: (intake.preferences ?? {}) as JobPreferences,
        target_job_url: intake.target_job_url ?? null,
        target_job_description: intake.target_jd ?? null,
        fullName: order.full_name ?? ""
      });

      await createQcResult({ ...repaired.qc, run_id: repaired.runId ?? latestRun?.id ?? null });

      if (tier.shipsAutomatically && (repaired.qc.hard_fail || repaired.qc.confidence_total < Number(process.env.QC_AUTO_SHIP_THRESHOLD ?? "0.82"))) {
        await updateOrderStatus(id, "auto_qc_failed");
        return NextResponse.json({ success: true, status: "auto_qc_failed" }, { status: 200 });
      }

      const finalJobs = repaired.qc.valid_jobs.length ? repaired.qc.valid_jobs : repaired.jobs;
      const runId = repaired.runId ?? latestRun?.id;
      if (runId && finalJobs.length) {
        await replaceJobsForRun(runId, id, finalJobs);
      }
      await updateIntakeOutputs({
        intakeId: intake.id,
        outreach_text: repaired.outreachDraft,
        gap_suggestions: repaired.gapDraft,
        cert_suggestions: repaired.certDraft,
        resume_ats_text: tier.flags.includeFullResumeRewrite ? repaired.resumeDraft : null,
        resume_patch_notes: tier.flags.includeResumePatchNotes ? repaired.resumeDraft : null,
        keyword_map: repaired.keywordMap
      });

      const summary = `Target roles: ${(intake.target_titles ?? []).join(", ")}. Top matches scored and ranked. Report generated by C&L.`;
      const reportPdf = await renderReportPdf({
        candidateName: order.full_name ?? "Client",
        summary,
        jobs: finalJobs,
        gaps: repaired.gapDraft,
        certs: repaired.certDraft,
        outreach: repaired.outreachDraft,
        includeResume: tier.flags.includeFullResumeRewrite,
        patchNotes: tier.flags.includeResumePatchNotes ? repaired.resumeDraft : "",
        keywordMap: repaired.keywordMap
      });

      const reportPath = `reports/${id}/report.pdf`;
      await uploadBuffer("reports", reportPath, reportPdf, "application/pdf");
      await createArtifact({ order_id: id, kind: "report_pdf", storage_path: reportPath });

      if (tier.flags.includeFullResumeRewrite) {
        const resumePdf = await renderResumePdf({ fullName: order.full_name ?? "Client", content: repaired.resumeDraft });
        const resumeDocx = await renderResumeDocx({ fullName: order.full_name ?? "Client", content: repaired.resumeDraft });
        const resumePdfPath = `reports/${id}/resume.pdf`;
        const resumeDocxPath = `reports/${id}/resume.docx`;
        await uploadBuffer("reports", resumePdfPath, resumePdf, "application/pdf");
        await uploadBuffer("reports", resumeDocxPath, resumeDocx, "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
        await createArtifact({ order_id: id, kind: "resume_pdf", storage_path: resumePdfPath });
        await createArtifact({ order_id: id, kind: "resume_docx", storage_path: resumeDocxPath });
      }

      if (tier.requiresHumanQA) {
        await updateOrderStatus(id, "needs_review");
      } else {
        await updateOrderStatus(id, "approved_auto");
        await updateOrderStatus(id, "delivered");
        await sendEmail({
          to: order.email,
          subject: "Your C&L Job Match report is ready",
          html: "<p>Your report is ready. Log in to your dashboard to download your assets.</p>"
        });
      }

      return NextResponse.json({ success: true }, { status: 200 });
    }

    const qc = await runQC({
      orderId: id,
      tier,
      jobs,
      resumeProfile,
      resumeDraft,
      outreachDraft,
      gapDraft,
      certDraft,
      keywordMap
    });
    await createQcResult({ ...qc, run_id: latestRun?.id ?? null });
    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    );
  }
}
