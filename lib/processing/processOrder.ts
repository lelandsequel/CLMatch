import { parseResumeText } from "../resume/parseResumeText";
import { extractResumeProfile } from "../llm/extractResumeProfile";
import { generateResumeATS } from "../llm/generateResumeATS";
import { generateResumePatchNotes } from "../llm/generateResumePatchNotes";
import { generateOutreach } from "../llm/generateOutreach";
import { generateCertsAndGaps } from "../llm/generateCertsAndGaps";
import { generatePivotPathways } from "../llm/generatePivotPathways";
import { renderReportPdf } from "../report/renderReportPdf";
import { renderResumePdf } from "../report/renderResumePdf";
import { renderResumeDocx } from "../report/renderResumeDocx";
import { uploadBuffer } from "../storage";
import { runJobPipeline } from "../jobs/pipeline";
import { replaceJobsForRun } from "../jobs/persist";
import type { JobPreferences } from "../jobs/types";
import {
  updateIntakeProfile,
  updateIntakeOutputs,
  updateOrderStatus,
  createArtifact,
  findOrderById
} from "../orders";
import { sendEmail } from "../email";
import { getTier } from "../pricing";
import { runQC } from "../qc";
import { createQcResult } from "../qc/persist";
import { repairArtifacts } from "../qc/repair";

export async function processOrder(payload: {
  orderId: string;
  intakeId: string;
  fullName: string;
  email: string;
  tierId: string;
  resumeFileName: string;
  resumeBuffer: Buffer;
  targetTitles: string[];
  preferences: JobPreferences;
  target_job_url?: string | null;
  target_jd?: string | null;
}) {
  await updateOrderStatus(payload.orderId, "processing");
  const tier = getTier(payload.tierId) ?? getTier("offer_farming_report");
  if (!tier) {
    throw new Error("Invalid tier");
  }

  const resumeText = await parseResumeText(payload.resumeFileName, payload.resumeBuffer);
  const profile = await extractResumeProfile(resumeText);
  await updateIntakeProfile(payload.intakeId, profile as Record<string, unknown>);

  let atsResume = tier.flags.includeFullResumeRewrite
    ? await generateResumeATS({
        fullName: payload.fullName,
        baseText: resumeText,
        profile
      })
    : "";

  let patchNotes = tier.flags.includeResumePatchNotes
    ? await generateResumePatchNotes({
        fullName: payload.fullName,
        resumeText,
        profile,
        targetTitles: payload.targetTitles
      })
    : "";

  const pipelineResult = await runJobPipeline({
    candidate_id: payload.orderId,
    order_id: payload.orderId,
    resume_profile_json: profile,
    preferences: {
      ...payload.preferences,
      preferred_titles: payload.targetTitles
    },
    target_job_url: payload.target_job_url ?? null,
    target_job_description: payload.target_jd ?? null,
    max_results: tier.limits.maxJobs
  });

  let jobs = pipelineResult.jobs;
  let runId = pipelineResult.run_id;
  const companyList = jobs.map((job) => job.company_name);
  const outreach = tier.flags.includeOutreachKit
    ? await generateOutreach({
        fullName: payload.fullName,
        targetTitles: payload.targetTitles,
        companyList
      })
    : "";

  let trimmedOutreach = formatOutreachForTier(outreach, tier.id);

  const summary = `Target roles: ${payload.targetTitles.join(", ")}. Top matches scored and ranked. Report generated by C&L.`;
  let { gaps, certs } = tier.flags.includeCertPlan
    ? await generateCertsAndGaps({
        profileSummary: summary,
        targetTitles: payload.targetTitles
      })
    : { gaps: [], certs: [] };

  let keywordMap = tier.flags.includeKeywordMap
    ? Array.from(new Set([...profile.keywords, ...profile.skills, ...profile.tools])).slice(0, tier.id === "ghost_proof_list" ? 5 : 12)
    : [];

  const pivotPathways = tier.includesPivotPathways
    ? await generatePivotPathways({
        resumeText,
        profile,
        targetTitles: payload.targetTitles,
        preferences: payload.preferences
      })
    : null;

  let qc = await runQC({
    orderId: payload.orderId,
    tier,
    jobs,
    resumeProfile: profile,
    resumeDraft: tier.flags.includeFullResumeRewrite ? atsResume : patchNotes,
    outreachDraft: trimmedOutreach,
    gapDraft: gaps,
    certDraft: certs,
    keywordMap
  });

  if (tier.shipsAutomatically && (qc.hard_fail || qc.confidence_total < getAutoShipThreshold())) {
    await updateOrderStatus(payload.orderId, "qc_repairing");
    const repaired = await repairArtifacts({
      orderId: payload.orderId,
      tier,
      jobs,
      resumeProfile: profile,
      resumeDraft: tier.flags.includeFullResumeRewrite ? atsResume : patchNotes,
      outreachDraft: trimmedOutreach,
      gapDraft: gaps,
      certDraft: certs,
      keywordMap,
      targetTitles: payload.targetTitles,
      preferences: payload.preferences,
      target_job_url: payload.target_job_url ?? null,
      target_job_description: payload.target_jd ?? null,
      fullName: payload.fullName
    });
    qc = repaired.qc;
    jobs = repaired.jobs;
    if (repaired.runId) {
      runId = repaired.runId;
    }
    if (tier.flags.includeFullResumeRewrite) {
      atsResume = repaired.resumeDraft;
    } else {
      patchNotes = repaired.resumeDraft;
    }
    trimmedOutreach = repaired.outreachDraft;
    gaps = repaired.gapDraft;
    certs = repaired.certDraft;
    keywordMap = repaired.keywordMap;
  }

  await createQcResult({ ...qc, run_id: runId });

  if (tier.shipsAutomatically && (qc.hard_fail || qc.confidence_total < getAutoShipThreshold())) {
    await updateOrderStatus(payload.orderId, "auto_qc_failed");
    return;
  }

  const finalJobs = qc.valid_jobs.length ? qc.valid_jobs : jobs;
  if (runId && finalJobs.length) {
    await replaceJobsForRun(runId, payload.orderId, finalJobs);
  }
  await updateIntakeOutputs({
    intakeId: payload.intakeId,
    outreach_text: trimmedOutreach,
    gap_suggestions: gaps,
    cert_suggestions: certs,
    resume_ats_text: tier.flags.includeFullResumeRewrite ? atsResume : null,
    resume_patch_notes: patchNotes || null,
    keyword_map: keywordMap,
    pivot_pathways_json: pivotPathways
  });

  const reportPdf = await renderReportPdf({
    candidateName: payload.fullName,
    summary,
    jobs: finalJobs,
    gaps,
    certs,
    outreach: trimmedOutreach,
    includeResume: tier.flags.includeFullResumeRewrite,
    patchNotes,
    keywordMap,
    pivotPathways
  });

  const reportPath = `reports/${payload.orderId}/report.pdf`;
  await uploadBuffer("reports", reportPath, reportPdf, "application/pdf");
  await createArtifact({ order_id: payload.orderId, kind: "report_pdf", storage_path: reportPath });

  if (tier.flags.includeFullResumeRewrite) {
    const resumePdf = await renderResumePdf({ fullName: payload.fullName, content: atsResume });
    const resumeDocx = await renderResumeDocx({ fullName: payload.fullName, content: atsResume });
    const resumePdfPath = `reports/${payload.orderId}/resume.pdf`;
    const resumeDocxPath = `reports/${payload.orderId}/resume.docx`;
    await uploadBuffer("reports", resumePdfPath, resumePdf, "application/pdf");
    await uploadBuffer("reports", resumeDocxPath, resumeDocx, "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
    await createArtifact({ order_id: payload.orderId, kind: "resume_pdf", storage_path: resumePdfPath });
    await createArtifact({ order_id: payload.orderId, kind: "resume_docx", storage_path: resumeDocxPath });
  }

  const order = await findOrderById(payload.orderId);
  const premiumAlwaysReview = process.env.QC_PREMIUM_ALWAYS_REVIEW !== "false";
  if (tier.requiresHumanQA && premiumAlwaysReview) {
    await updateOrderStatus(payload.orderId, "needs_review");
    if (order) {
      await sendEmail({
        to: order.email,
        subject: "Your report is in executive review",
        html: "<p>Your report is in executive review. We'll notify you when delivery is complete.</p>"
      });
    }
    return;
  }

  await updateOrderStatus(payload.orderId, "approved_auto");
  if (order) {
    await deliverOrder(order.email, payload.orderId);
  }
}

function formatOutreachForTier(outreach: string, tierId: string) {
  if (!outreach) return "";
  const [recruiterBlock, hmBlockRaw] = outreach.split(/Hiring manager outreach:/i);
  const recruiter = recruiterBlock?.replace(/Recruiter outreach:/i, "").trim() ?? "";
  const hmBlock = hmBlockRaw ?? "";
  const [hmContent, cadence] = hmBlock.split(/Cadence:/i);
  const hm = hmContent.trim();

  if (tierId === "job_radar") {
    return `Recruiter outreach:\n${recruiter}`;
  }

  if (tierId === "ghost_proof_list") {
    return `Recruiter outreach:\n${recruiter}\n\nHiring manager outreach:\n${hm}`;
  }

  if (tierId === "interview_boost_kit") {
    const cadenceLines = cadence
      ? cadence
          .trim()
          .split("\n")
          .slice(0, 2)
          .join("\n")
      : "";
    return `Recruiter outreach:\n${recruiter}\n\nHiring manager outreach:\n${hm}\n\nCadence:\n${cadenceLines}`;
  }

  return outreach;
}

function getAutoShipThreshold() {
  const parsed = Number(process.env.QC_AUTO_SHIP_THRESHOLD ?? "0.82");
  return Number.isFinite(parsed) ? parsed : 0.82;
}

async function deliverOrder(email: string, orderId: string) {
  await updateOrderStatus(orderId, "delivered");
  await sendEmail({
    to: email,
    subject: "Your C&L Job Match report is ready",
    html: "<p>Your report is ready. Log in to your dashboard to download your assets.</p>"
  });
}
